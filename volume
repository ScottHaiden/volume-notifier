#!/usr/bin/env python3

import argparse
import fcntl
import os
import pathlib
import re
import subprocess


_RUNPATH = pathlib.Path(f"/run/user/{os.getuid()}")
_DB_PATH = _RUNPATH / "volume.id"
_MUTE_RE = re.compile(r"Mute: (yes|no)")

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()

    parser.add_argument("-p", "--db-path", type=pathlib.Path, default=_DB_PATH)
    parser.add_argument("-i", "--interval", type=int, default=512)
    parser.add_argument("-s", "--sink", type=str, default="@DEFAULT_SINK@")
    parser.add_argument("task", type=str)

    return parser.parse_args()


def get_pactl_status(status: str) -> str:
    cmd = ["pactl", f"get-sink-{status}", "@DEFAULT_SINK@"]
    return subprocess.check_output(cmd).decode()


def parse_volume(vol: str) -> str | None:
    match = re.match(r"Volume: (.*),\s+(.*)", vol)
    if match is None: return None
    return match.groups()


def read_db(fhandle: int) -> int:
    fhandle.seek(0)
    try:
        return int(fhandle.read())
    except ValueError:
        return None


def write_db(fhandle, new_id: int):
    fhandle.truncate(0)
    fhandle.write(str(new_id))


def get_icon(mutestr: str, channels: list[str]) -> str:
    if match := re.match("^Mute: (yes|no)$", mutestr):
        if match.group(1) == "yes": return "audio-volume-muted"

    pct_re = re.compile(r"([^ ]+): ([0-9]+) / \s*([0-9]+)% / (-?[0-9.]+ dB)$")

    pcts = map(pct_re.match, channels)
    pcts = filter(None, pcts)
    pcts = (pct.group(3) for pct in pcts)
    pcts = map(int, pcts)
    pcts = sum(pcts)
    average = pcts / len(channels)

    if average < 33:
        return "audio-volume-low"
    if average < 66:
        return "audio-volume-medium"
    return "audio-volume-high"


def get_command_or_die(args: argparse.Namespace) -> list[str]:
    match args.task:
        case "up":
            return ["pactl", "set-sink-volume", args.sink, f"+{args.interval}"]
        case "down":
            return ["pactl", "set-sink-volume", args.sink, f"-{args.interval}"]
        case "mute":
            return ["pactl", "set-sink-mute", args.sink, "toggle"]
        case "noop":
            return ["true"]
        case _:
            raise SystemExit(f"Unknown task '{args.task}'")

def main(args: argparse.Namespace):
    subprocess.check_call(get_command_or_die(args))

    mute = get_pactl_status("mute").strip()
    volume = get_pactl_status("volume")
    channels = parse_volume(volume)
    status = "\n".join([mute] + [f"- {channel}" for channel in channels])

    with open(args.db_path, "a+") as db:
        fcntl.flock(db.fileno(), fcntl.LOCK_SH)
        os.fchmod(db.fileno(), 0o600)

        # Read the DB under a shared lock. If it's empty, then upgrade to an
        # exclusive lock (a non atomic operation), and check again. If it's
        # *still* empty, then we'll get a new ID and write it to the DB.
        if (old := read_db(db)) is None:
            fcntl.flock(db.fileno(), fcntl.LOCK_EX)
            old = read_db(db)

        cmd = ["notify-send", "Volume", status,
               "-p", "-i", get_icon(mute, channels)]
        cmd += ["-r", str(old)] if old is not None else []

        new_id = int(subprocess.check_output(cmd).decode())

        if old is None: write_db(db, new_id)


if __name__ == "__main__":
    main(parse_args())
