#!/usr/bin/env python3

import argparse
import contextlib
import fcntl
import json
import os
import pathlib
import re
import subprocess


_RUNPATH = pathlib.Path(f"/run/user/{os.getuid()}")
_DB_PATH = _RUNPATH / "volume.id"
_MUTE_RE = re.compile(r"Mute: (yes|no)")

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()

    parser.add_argument("-p", "--db-path", type=pathlib.Path, default=_DB_PATH)
    parser.add_argument("-i", "--interval", type=int, default=1000)
    parser.add_argument("-s", "--sink", type=str, default="@DEFAULT_SINK@")
    parser.add_argument("task", type=str)

    return parser.parse_args()


def get_pactl_status(status: str) -> str:
    cmd = ["pactl", f"get-sink-{status}", "@DEFAULT_SINK@"]
    return subprocess.check_output(cmd).decode()


def parse_volume(vol: str) -> str | None:
    match = re.match(r"Volume: (.*),\s+(.*)", vol)
    if match is None: return None
    return match.groups()


@contextlib.contextmanager
def lock_db(path: pathlib.Path):
    try:
        fhandle = path.open("a+")
        fcntl.flock(fhandle.fileno(), fcntl.LOCK_SH)
        os.fchmod(fhandle.fileno(), 0o600)
        fhandle.seek(0)
        yield fhandle
    finally:
        fhandle.close()


def read_db(fhandle: int) -> int:
    fhandle.seek(0)
    try:
        return json.load(fhandle)
    except json.decoder.JSONDecodeError:
        return None


def write_db(fhandle, new_id: int):
    fhandle.truncate(0)
    json.dump(new_id, fhandle)


def get_icon(mutestr: str, channels: list[str]) -> str:
    if match := re.match("^Mute: (yes|no)$", mutestr):
        if match.group(1) == "yes": return "audio-volume-muted"

    pct_re = re.compile(r"([^ ]+): ([0-9]+) / \s*([0-9]+)% / (-?[0-9.]+ dB)$")

    pcts = map(pct_re.match, channels)
    pcts = filter(None, pcts)
    pcts = (pct.group(3) for pct in pcts)
    pcts = map(int, pcts)
    pcts = sum(pcts)
    average = pcts / len(channels)

    if average < 33:
        return "audio-volume-low"
    if average < 66:
        return "audio-volume-medium"
    return "audio-volume-high"


def main(args: argparse.Namespace):
    cmds = {"up": ["pactl", "set-sink-volume", args.sink, f"+{args.interval}"],
            "down": ["pactl", "set-sink-volume", args.sink, f"-{args.interval}"],
            "mute": ["pactl", "set-sink-mute", args.sink, "toggle"],
            "noop": ["true"]}

    with lock_db(args.db_path) as db:
        if cmd := cmds.get(args.task):
            subprocess.check_call(cmd)
        else:
            raise SystemExit(f"Invalid task {args.task}")

        mute = get_pactl_status("mute").strip()
        volume = get_pactl_status("volume")
        channels = parse_volume(volume)
        status = "\n".join([mute] + [f"- {channel}" for channel in channels])

        old = read_db(db)

        cmd = ["notify-send", "Volume", status, "-p",
               "-i", get_icon(mute, channels)]
        if old is not None:
            cmd += ["-r", str(old)]

        new_id = int(subprocess.check_output(cmd).decode())

        # If we didn't get an id to start, upgrade our lock. This is a
        # non-atomic operation, so after we relock, check again to see if
        # another process created an ID and saved it.
        if old is None:
            print("Upgrading lock")
            fcntl.flock(db.fileno(), fcntl.LOCK_EX)
            if read_db(db) is None:
                print("updating db")
                write_db(db, new_id)


if __name__ == "__main__":
    main(parse_args())
